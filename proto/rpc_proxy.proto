syntax = "proto3";

package lnrpc_proxy;

option go_package = "github.com/stakwork/sphinx-proxy/lnrpc";

/*
 * Comments in this file will be directly parsed into the API
 * Documentation as descriptions of the associated method, message, or field.
 * These descriptions should go right above the definition of the object, and
 * can be in either block or // comment format.
 *
 * An RPC method can be matched to an lncli command by placing a line in the
 * beginning of the description in exactly the following format:
 * lncli: `methodname`
 *
 * Failure to specify the exact name of the command will cause documentation
 * generation to fail.
 *
 * More information on how exactly the gRPC documentation is generated from
 * this proto file can be found here:
 * https://github.com/lightninglabs/lightning-api
 */

// Lightning is the main RPC server of the daemon.
service Lightning {

    /* lncli: `channelbalance`
    ChannelBalance returns a report on the total funds across all open channels,
    categorized in local/remote, pending local/remote and unsettled local/remote
    balances.
    */
    rpc ChannelBalance (ChannelBalanceRequest) returns (ChannelBalanceResponse);

    /* lncli: `signmessage`
    SignMessage signs a message with this node's private key. The returned
    signature string is `zbase32` encoded and pubkey recoverable, meaning that
    only the message digest and signature are needed for verification.
    */
    rpc SignMessage (SignMessageRequest) returns (SignMessageResponse);

    /* lncli: `verifymessage`
    VerifyMessage verifies a signature over a msg. The signature must be
    zbase32 encoded and signed by an active node in the resident node's
    channel database. In addition to returning the validity of the signature,
    VerifyMessage also returns the recovered pubkey from the signature.
    */
    rpc VerifyMessage (VerifyMessageRequest) returns (VerifyMessageResponse);

    /* lncli: `getinfo`
    GetInfo returns general information concerning the lightning node including
    it's identity pubkey, alias, the chains it is connected to, and information
    concerning the number of open+pending channels.
    */
    rpc GetInfo (GetInfoRequest) returns (GetInfoResponse);

    /* lncli: `listchannels`
    ListChannels returns a description of all the open channels that this node
    is a participant in.
    */
    rpc ListChannels (ListChannelsRequest) returns (ListChannelsResponse);

    /* lncli: `getchaninfo`
    GetChanInfo returns the latest authenticated network announcement for the
    given channel identified by its channel ID: an 8-byte integer which
    uniquely identifies the location of transaction's funding output within the
    blockchain.
    */
    rpc GetChanInfo (ChanInfoRequest) returns (ChannelEdge);

    /*
    SendPaymentSync is the synchronous non-streaming version of SendPayment.
    This RPC is intended to be consumed by clients of the REST proxy.
    Additionally, this RPC expects the destination's public key and the payment
    hash (if any) to be encoded as hex strings.
    */
    rpc SendPaymentSync (SendRequest) returns (SendResponse);

    /* lncli: `addinvoice`
    AddInvoice attempts to add a new invoice to the invoice database. Any
    duplicated invoices are rejected, therefore all invoices *must* have a
    unique payment preimage.
    */
    rpc AddInvoice (Invoice) returns (AddInvoiceResponse);

    /*
    SubscribeInvoices returns a uni-directional stream (server -> client) for
    notifying the client of newly added/settled invoices. The caller can
    optionally specify the add_index and/or the settle_index. If the add_index
    is specified, then we'll first start by sending add invoice events for all
    invoices with an add_index greater than the specified value. If the
    settle_index is specified, the next, we'll send out all settle events for
    invoices with a settle_index greater than the specified value. One or both
    of these fields can be set. If no fields are set, then we'll only send out
    the latest add/settle events.
    */
    rpc SubscribeInvoices (InvoiceSubscription) returns (stream Invoice);

    /* lncli: `queryroutes`
    QueryRoutes attempts to query the daemon's Channel Router for a possible
    route to a target destination capable of carrying a specific amount of
    satoshis. The returned route contains the full details required to craft and
    send an HTLC, also including the necessary information that should be
    present within the Sphinx packet encapsulated within the HTLC.

    When using REST, the `dest_custom_records` map type can be set by appending
    `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
    to the URL. Unfortunately this map type doesn't appear in the REST API
    documentation because of a bug in the grpc-gateway library.
    */
    rpc QueryRoutes (QueryRoutesRequest) returns (QueryRoutesResponse);

}

message FeeLimit {
    oneof limit {
        /*
        The fee limit expressed as a fixed amount of satoshis.

        The fields fixed and fixed_msat are mutually exclusive.
        */
        int64 fixed = 1;

        /*
        The fee limit expressed as a fixed amount of millisatoshis.

        The fields fixed and fixed_msat are mutually exclusive.
        */
        int64 fixed_msat = 3;

        // The fee limit expressed as a percentage of the payment amount.
        int64 percent = 2;
    }
}

message SendRequest {
    /*
    The identity pubkey of the payment recipient. When using REST, this field
    must be encoded as base64.
    */
    bytes dest = 1;

    /*
    The hex-encoded identity pubkey of the payment recipient. Deprecated now
    that the REST gateway supports base64 encoding of bytes fields.
    */
    string dest_string = 2 [deprecated = true];

    /*
    The amount to send expressed in satoshis.

    The fields amt and amt_msat are mutually exclusive.
    */
    int64 amt = 3;

    /*
    The amount to send expressed in millisatoshis.

    The fields amt and amt_msat are mutually exclusive.
    */
    int64 amt_msat = 12;

    /*
    The hash to use within the payment's HTLC. When using REST, this field
    must be encoded as base64.
    */
    bytes payment_hash = 4;

    /*
    The hex-encoded hash to use within the payment's HTLC. Deprecated now
    that the REST gateway supports base64 encoding of bytes fields.
    */
    string payment_hash_string = 5 [deprecated = true];

    /*
    A bare-bones invoice for a payment within the Lightning Network. With the
    details of the invoice, the sender has all the data necessary to send a
    payment to the recipient.
    */
    string payment_request = 6;

    /*
    The CLTV delta from the current height that should be used to set the
    timelock for the final hop.
    */
    int32 final_cltv_delta = 7;

    /*
    The maximum number of satoshis that will be paid as a fee of the payment.
    This value can be represented either as a percentage of the amount being
    sent, or as a fixed amount of the maximum fee the user is willing the pay to
    send the payment.
    */
    FeeLimit fee_limit = 8;

    /*
    The channel id of the channel that must be taken to the first hop. If zero,
    any channel may be used.
    */
    uint64 outgoing_chan_id = 9 [jstype = JS_STRING];

    /*
    The pubkey of the last hop of the route. If empty, any hop may be used.
    */
    bytes last_hop_pubkey = 13;

    /*
    An optional maximum total time lock for the route. This should not exceed
    lnd's `--max-cltv-expiry` setting. If zero, then the value of
    `--max-cltv-expiry` is enforced.
    */
    uint32 cltv_limit = 10;

    /*
    An optional field that can be used to pass an arbitrary set of TLV records
    to a peer which understands the new records. This can be used to pass
    application specific data during the payment attempt. Record types are
    required to be in the custom range >= 65536. When using REST, the values
    must be encoded as base64.
    */
    map<uint64, bytes> dest_custom_records = 11;

    // If set, circular payments to self are permitted.
    bool allow_self_payment = 14;

    /*
    Features assumed to be supported by the final node. All transitive feature
    dependencies must also be set properly. For a given feature bit pair, either
    optional or remote may be set, but not both. If this field is nil or empty,
    the router will try to load destination features from the graph as a
    fallback.
    */
    repeated FeatureBit dest_features = 15;

     /*
    Optional route hints to reach the destination through private channels.
    */
    repeated RouteHint route_hints = 16;
}

message SendResponse {
    string payment_error = 1;
    bytes payment_preimage = 2;
    Route payment_route = 3;
    bytes payment_hash = 4;
}

message LightningAddress {
    // The identity pubkey of the Lightning node
    string pubkey = 1;

    // The network location of the lightning node, e.g. `69.69.69.69:1337` or
    // `localhost:10011`
    string host = 2;
}

message SignMessageRequest {
    /*
    The message to be signed. When using REST, this field must be encoded as
    base64.
    */
    bytes msg = 1;
}
message SignMessageResponse {
    // The signature for the given message
    string signature = 1;
    // The signature for the given message (hex encoded)
    string signature_hex = 2;
}

message VerifyMessageRequest {
    /*
    The message over which the signature is to be verified. When using REST,
    this field must be encoded as base64.
    */
    bytes msg = 1;

    // The signature to be verified over the given message
    string signature = 2;
}
message VerifyMessageResponse {
    // Whether the signature was valid over the given message
    bool valid = 1;

    // The pubkey recovered from the signature
    string pubkey = 2;
}

message HTLC {
    bool incoming = 1;
    int64 amount = 2;
    bytes hash_lock = 3;
    uint32 expiration_height = 4;

    // Index identifying the htlc on the channel.
    uint64 htlc_index = 5;

    // If this HTLC is involved in a forwarding operation, this field indicates
    // the forwarding channel. For an outgoing htlc, it is the incoming channel.
    // For an incoming htlc, it is the outgoing channel. When the htlc
    // originates from this node or this node is the final destination,
    // forwarding_channel will be zero. The forwarding channel will also be zero
    // for htlcs that need to be forwarded but don't have a forwarding decision
    // persisted yet.
    uint64 forwarding_channel = 6;

    // Index identifying the htlc on the forwarding channel.
    uint64 forwarding_htlc_index = 7;
}

enum CommitmentType {
    /*
    A channel using the legacy commitment format having tweaked to_remote
    keys.
    */
    LEGACY = 0;

    /*
    A channel that uses the modern commitment format where the key in the
    output of the remote party does not change each state. This makes back
    up and recovery easier as when the channel is closed, the funds go
    directly to that key.
    */
    STATIC_REMOTE_KEY = 1;

    /*
    A channel that uses a commitment format that has anchor outputs on the
    commitments, allowing fee bumping after a force close transaction has
    been broadcast.
    */
    ANCHORS = 2;

    /*
    Returned when the commitment type isn't known or unavailable.
    */
    UNKNOWN_COMMITMENT_TYPE = 999;
}

message ChannelConstraints {
    /*
    The CSV delay expressed in relative blocks. If the channel is force closed,
    we will need to wait for this many blocks before we can regain our funds.
    */
    uint32 csv_delay = 1;

    // The minimum satoshis this node is required to reserve in its balance.
    uint64 chan_reserve_sat = 2;

    // The dust limit (in satoshis) of the initiator's commitment tx.
    uint64 dust_limit_sat = 3;

    // The maximum amount of coins in millisatoshis that can be pending in this
    // channel.
    uint64 max_pending_amt_msat = 4;

    // The smallest HTLC in millisatoshis that the initiator will accept.
    uint64 min_htlc_msat = 5;

    // The total number of incoming HTLC's that the initiator will accept.
    uint32 max_accepted_htlcs = 6;
}

message Channel {
    // Whether this channel is active or not
    bool active = 1;

    // The identity pubkey of the remote node
    string remote_pubkey = 2;

    /*
    The outpoint (txid:index) of the funding transaction. With this value, Bob
    will be able to generate a signature for Alice's version of the commitment
    transaction.
    */
    string channel_point = 3;

    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 chan_id = 4 [jstype = JS_STRING];

    // The total amount of funds held in this channel
    int64 capacity = 5;

    // This node's current balance in this channel
    int64 local_balance = 6;

    // The counterparty's current balance in this channel
    int64 remote_balance = 7;

    /*
    The amount calculated to be paid in fees for the current set of commitment
    transactions. The fee amount is persisted with the channel in order to
    allow the fee amount to be removed and recalculated with each channel state
    update, including updates that happen after a system restart.
    */
    int64 commit_fee = 8;

    // The weight of the commitment transaction
    int64 commit_weight = 9;

    /*
    The required number of satoshis per kilo-weight that the requester will pay
    at all times, for both the funding transaction and commitment transaction.
    This value can later be updated once the channel is open.
    */
    int64 fee_per_kw = 10;

    // The unsettled balance in this channel
    int64 unsettled_balance = 11;

    /*
    The total number of satoshis we've sent within this channel.
    */
    int64 total_satoshis_sent = 12;

    /*
    The total number of satoshis we've received within this channel.
    */
    int64 total_satoshis_received = 13;

    /*
    The total number of updates conducted within this channel.
    */
    uint64 num_updates = 14;

    /*
    The list of active, uncleared HTLCs currently pending within the channel.
    */
    repeated HTLC pending_htlcs = 15;

    /*
    Deprecated. The CSV delay expressed in relative blocks. If the channel is
    force closed, we will need to wait for this many blocks before we can regain
    our funds.
    */
    uint32 csv_delay = 16 [deprecated = true];

    // Whether this channel is advertised to the network or not.
    bool private = 17;

    // True if we were the ones that created the channel.
    bool initiator = 18;

    // A set of flags showing the current state of the channel.
    string chan_status_flags = 19;

    // Deprecated. The minimum satoshis this node is required to reserve in its
    // balance.
    int64 local_chan_reserve_sat = 20 [deprecated = true];

    /*
    Deprecated. The minimum satoshis the other node is required to reserve in
    its balance.
    */
    int64 remote_chan_reserve_sat = 21 [deprecated = true];

    // Deprecated. Use commitment_type.
    bool static_remote_key = 22 [deprecated = true];

    // The commitment type used by this channel.
    CommitmentType commitment_type = 26;

    /*
    The number of seconds that the channel has been monitored by the channel
    scoring system. Scores are currently not persisted, so this value may be
    less than the lifetime of the channel [EXPERIMENTAL].
    */
    int64 lifetime = 23;

    /*
    The number of seconds that the remote peer has been observed as being online
    by the channel scoring system over the lifetime of the channel
    [EXPERIMENTAL].
    */
    int64 uptime = 24;

    /*
    Close address is the address that we will enforce payout to on cooperative
    close if the channel was opened utilizing option upfront shutdown. This
    value can be set on channel open by setting close_address in an open channel
    request. If this value is not set, you can still choose a payout address by
    cooperatively closing with the delivery_address field set.
    */
    string close_address = 25;

    /*
    The amount that the initiator of the channel optionally pushed to the remote
    party on channel open. This amount will be zero if the channel initiator did
    not push any funds to the remote peer. If the initiator field is true, we
    pushed this amount to our peer, if it is false, the remote peer pushed this
    amount to us.
    */
    uint64 push_amount_sat = 27;

    /*
    This uint32 indicates if this channel is to be considered 'frozen'. A
    frozen channel doest not allow a cooperative channel close by the
    initiator. The thaw_height is the height that this restriction stops
    applying to the channel. This field is optional, not setting it or using a
    value of zero will mean the channel has no additional restrictions. The
    height can be interpreted in two ways: as a relative height if the value is
    less than 500,000, or as an absolute height otherwise.
    */
    uint32 thaw_height = 28;

    // List constraints for the local node.
    ChannelConstraints local_constraints = 29;

    // List constraints for the remote node.
    ChannelConstraints remote_constraints = 30;
}

message ListChannelsRequest {
    bool active_only = 1;
    bool inactive_only = 2;
    bool public_only = 3;
    bool private_only = 4;

    /*
    Filters the response for channels with a target peer's pubkey. If peer is
    empty, all channels will be returned.
    */
    bytes peer = 5;
}
message ListChannelsResponse {
    // The list of active channels
    repeated Channel channels = 11;
}

message GetInfoRequest {
}
message GetInfoResponse {
    // The version of the LND software that the node is running.
    string version = 14;

    // The SHA1 commit hash that the daemon is compiled with.
    string commit_hash = 20;

    // The identity pubkey of the current node.
    string identity_pubkey = 1;

    // If applicable, the alias of the current node, e.g. "bob"
    string alias = 2;

    // The color of the current node in hex code format
    string color = 17;

    // Number of pending channels
    uint32 num_pending_channels = 3;

    // Number of active channels
    uint32 num_active_channels = 4;

    // Number of inactive channels
    uint32 num_inactive_channels = 15;

    // Number of peers
    uint32 num_peers = 5;

    // The node's current view of the height of the best block
    uint32 block_height = 6;

    // The node's current view of the hash of the best block
    string block_hash = 8;

    // Timestamp of the block best known to the wallet
    int64 best_header_timestamp = 13;

    // Whether the wallet's view is synced to the main chain
    bool synced_to_chain = 9;

    // Whether we consider ourselves synced with the public channel graph.
    bool synced_to_graph = 18;

    /*
    Whether the current node is connected to testnet. This field is
    deprecated and the network field should be used instead
    **/
    bool testnet = 10 [deprecated = true];

    reserved 11;

    // A list of active chains the node is connected to
    repeated Chain chains = 16;

    // The URIs of the current node.
    repeated string uris = 12;

    /*
    Features that our node has advertised in our init message, node
    announcements and invoices.
    */
    map<uint32, Feature> features = 19;
}

message Chain {
    // The blockchain the node is on (eg bitcoin, litecoin)
    string chain = 1;

    // The network the node is on (eg regtest, testnet, mainnet)
    string network = 2;
}

message Amount {
    // Value denominated in satoshis.
    uint64 sat = 1;

    // Value denominated in milli-satoshis.
    uint64 msat = 2;
}

message ChannelBalanceRequest {
}
message ChannelBalanceResponse {
    // Deprecated. Sum of channels balances denominated in satoshis
    int64 balance = 1 [deprecated = true];

    // Deprecated. Sum of channels pending balances denominated in satoshis
    int64 pending_open_balance = 2 [deprecated = true];

    // Sum of channels local balances.
    Amount local_balance = 3;

    // Sum of channels remote balances.
    Amount remote_balance = 4;

    // Sum of channels local unsettled balances.
    Amount unsettled_local_balance = 5;

    // Sum of channels remote unsettled balances.
    Amount unsettled_remote_balance = 6;

    // Sum of channels pending local balances.
    Amount pending_open_local_balance = 7;

    // Sum of channels pending remote balances.
    Amount pending_open_remote_balance = 8;
}

message QueryRoutesRequest {
    // The 33-byte hex-encoded public key for the payment destination
    string pub_key = 1;

    /*
    The amount to send expressed in satoshis.

    The fields amt and amt_msat are mutually exclusive.
    */
    int64 amt = 2;

    /*
    The amount to send expressed in millisatoshis.

    The fields amt and amt_msat are mutually exclusive.
    */
    int64 amt_msat = 12;

    reserved 3;

    /*
    An optional CLTV delta from the current height that should be used for the
    timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
    not add any additional block padding on top of final_ctlv_delta. This
    padding of a few blocks needs to be added manually or otherwise failures may
    happen when a block comes in while the payment is in flight.
    */
    int32 final_cltv_delta = 4;

    /*
    The maximum number of satoshis that will be paid as a fee of the payment.
    This value can be represented either as a percentage of the amount being
    sent, or as a fixed amount of the maximum fee the user is willing the pay to
    send the payment.
    */
    FeeLimit fee_limit = 5;

    /*
    A list of nodes to ignore during path finding. When using REST, these fields
    must be encoded as base64.
    */
    repeated bytes ignored_nodes = 6;

    /*
    Deprecated. A list of edges to ignore during path finding.
    */
    repeated EdgeLocator ignored_edges = 7 [deprecated = true];

    /*
    The source node where the request route should originated from. If empty,
    self is assumed.
    */
    string source_pub_key = 8;

    /*
    If set to true, edge probabilities from mission control will be used to get
    the optimal route.
    */
    bool use_mission_control = 9;

    /*
    A list of directed node pairs that will be ignored during path finding.
    */
    repeated NodePair ignored_pairs = 10;

    /*
    An optional maximum total time lock for the route. If the source is empty or
    ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
    zero, then the value of `--max-cltv-expiry` is used as the limit.
    */
    uint32 cltv_limit = 11;

    /*
    An optional field that can be used to pass an arbitrary set of TLV records
    to a peer which understands the new records. This can be used to pass
    application specific data during the payment attempt. If the destination
    does not support the specified recrods, and error will be returned.
    Record types are required to be in the custom range >= 65536. When using
    REST, the values must be encoded as base64.
    */
    map<uint64, bytes> dest_custom_records = 13;

    /*
    The channel id of the channel that must be taken to the first hop. If zero,
    any channel may be used.
    */
    uint64 outgoing_chan_id = 14 [jstype = JS_STRING];

    /*
    The pubkey of the last hop of the route. If empty, any hop may be used.
    */
    bytes last_hop_pubkey = 15;

    /*
    Optional route hints to reach the destination through private channels.
    */
    repeated lnrpc_proxy.RouteHint route_hints = 16;

    /*
    Features assumed to be supported by the final node. All transitive feature
    dependencies must also be set properly. For a given feature bit pair, either
    optional or remote may be set, but not both. If this field is nil or empty,
    the router will try to load destination features from the graph as a
    fallback.
    */
    repeated lnrpc_proxy.FeatureBit dest_features = 17;
}

message NodePair {
    /*
    The sending node of the pair. When using REST, this field must be encoded as
    base64.
    */
    bytes from = 1;

    /*
    The receiving node of the pair. When using REST, this field must be encoded
    as base64.
    */
    bytes to = 2;
}

message EdgeLocator {
    // The short channel id of this edge.
    uint64 channel_id = 1 [jstype = JS_STRING];

    /*
    The direction of this edge. If direction_reverse is false, the direction
    of this edge is from the channel endpoint with the lexicographically smaller
    pub key to the endpoint with the larger pub key. If direction_reverse is
    is true, the edge goes the other way.
    */
    bool direction_reverse = 2;
}

message QueryRoutesResponse {
    /*
    The route that results from the path finding operation. This is still a
    repeated field to retain backwards compatibility.
    */
    repeated Route routes = 1;

    /*
    The success probability of the returned route based on the current mission
    control state. [EXPERIMENTAL]
    */
    double success_prob = 2;
}

message Hop {
    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 chan_id = 1 [jstype = JS_STRING];
    int64 chan_capacity = 2;
    int64 amt_to_forward = 3 [deprecated = true];
    int64 fee = 4 [deprecated = true];
    uint32 expiry = 5;
    int64 amt_to_forward_msat = 6;
    int64 fee_msat = 7;

    /*
    An optional public key of the hop. If the public key is given, the payment
    can be executed without relying on a copy of the channel graph.
    */
    string pub_key = 8;

    /*
    If set to true, then this hop will be encoded using the new variable length
    TLV format. Note that if any custom tlv_records below are specified, then
    this field MUST be set to true for them to be encoded properly.
    */
    bool tlv_payload = 9;

    /*
    An optional TLV record that signals the use of an MPP payment. If present,
    the receiver will enforce that that the same mpp_record is included in the
    final hop payload of all non-zero payments in the HTLC set. If empty, a
    regular single-shot payment is or was attempted.
    */
    MPPRecord mpp_record = 10;

    /*
    An optional set of key-value TLV records. This is useful within the context
    of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
    to drop off at each hop within the onion.
    */
    map<uint64, bytes> custom_records = 11;
}

message MPPRecord {
    /*
    A unique, random identifier used to authenticate the sender as the intended
    payer of a multi-path payment. The payment_addr must be the same for all
    subpayments, and match the payment_addr provided in the receiver's invoice.
    The same payment_addr must be used on all subpayments.
    */
    bytes payment_addr = 11;

    /*
    The total amount in milli-satoshis being sent as part of a larger multi-path
    payment. The caller is responsible for ensuring subpayments to the same node
    and payment_hash sum exactly to total_amt_msat. The same
    total_amt_msat must be used on all subpayments.
    */
    int64 total_amt_msat = 10;
}

/*
A path through the channel graph which runs over one or more channels in
succession. This struct carries all the information required to craft the
Sphinx onion packet, and send the payment along the first hop in the path. A
route is only selected as valid if all the channels have sufficient capacity to
carry the initial payment amount after fees are accounted for.
*/
message Route {
    /*
    The cumulative (final) time lock across the entire route. This is the CLTV
    value that should be extended to the first hop in the route. All other hops
    will decrement the time-lock as advertised, leaving enough time for all
    hops to wait for or present the payment preimage to complete the payment.
    */
    uint32 total_time_lock = 1;

    /*
    The sum of the fees paid at each hop within the final route. In the case
    of a one-hop payment, this value will be zero as we don't need to pay a fee
    to ourselves.
    */
    int64 total_fees = 2 [deprecated = true];

    /*
    The total amount of funds required to complete a payment over this route.
    This value includes the cumulative fees at each hop. As a result, the HTLC
    extended to the first-hop in the route will need to have at least this many
    satoshis, otherwise the route will fail at an intermediate node due to an
    insufficient amount of fees.
    */
    int64 total_amt = 3 [deprecated = true];

    /*
    Contains details concerning the specific forwarding details at each hop.
    */
    repeated Hop hops = 4;

    /*
    The total fees in millisatoshis.
    */
    int64 total_fees_msat = 5;

    /*
    The total amount in millisatoshis.
    */
    int64 total_amt_msat = 6;
}

message RoutingPolicy {
    uint32 time_lock_delta = 1;
    int64 min_htlc = 2;
    int64 fee_base_msat = 3;
    int64 fee_rate_milli_msat = 4;
    bool disabled = 5;
    uint64 max_htlc_msat = 6;
    uint32 last_update = 7;
}

/*
A fully authenticated channel along with all its unique attributes.
Once an authenticated channel announcement has been processed on the network,
then an instance of ChannelEdgeInfo encapsulating the channels attributes is
stored. The other portions relevant to routing policy of a channel are stored
within a ChannelEdgePolicy for each direction of the channel.
*/
message ChannelEdge {
    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 channel_id = 1 [jstype = JS_STRING];
    string chan_point = 2;

    uint32 last_update = 3 [deprecated = true];

    string node1_pub = 4;
    string node2_pub = 5;

    int64 capacity = 6;

    RoutingPolicy node1_policy = 7;
    RoutingPolicy node2_policy = 8;
}

message ChanInfoRequest {
    /*
    The unique channel ID for the channel. The first 3 bytes are the block
    height, the next 3 the index within the block, and the last 2 bytes are the
    output index for the channel.
    */
    uint64 chan_id = 1 [jstype = JS_STRING];
}

message HopHint {
    // The public key of the node at the start of the channel.
    string node_id = 1;

    // The unique identifier of the channel.
    uint64 chan_id = 2 [jstype = JS_STRING];

    // The base fee of the channel denominated in millisatoshis.
    uint32 fee_base_msat = 3;

    /*
    The fee rate of the channel for sending one satoshi across it denominated in
    millionths of a satoshi.
    */
    uint32 fee_proportional_millionths = 4;

    // The time-lock delta of the channel.
    uint32 cltv_expiry_delta = 5;
}

message RouteHint {
    /*
    A list of hop hints that when chained together can assist in reaching a
    specific destination.
    */
    repeated HopHint hop_hints = 1;
}

message Invoice {
    /*
    An optional memo to attach along with the invoice. Used for record keeping
    purposes for the invoice's creator, and will also be set in the description
    field of the encoded payment request if the description_hash field is not
    being used.
    */
    string memo = 1;

    reserved 2;

    /*
    The hex-encoded preimage (32 byte) which will allow settling an incoming
    HTLC payable to this preimage. When using REST, this field must be encoded
    as base64.
    */
    bytes r_preimage = 3;

    /*
    The hash of the preimage. When using REST, this field must be encoded as
    base64.
    */
    bytes r_hash = 4;

    /*
    The value of this invoice in satoshis

    The fields value and value_msat are mutually exclusive.
    */
    int64 value = 5;

    /*
    The value of this invoice in millisatoshis

    The fields value and value_msat are mutually exclusive.
    */
    int64 value_msat = 23;

    // Whether this invoice has been fulfilled
    bool settled = 6 [deprecated = true];

    // When this invoice was created
    int64 creation_date = 7;

    // When this invoice was settled
    int64 settle_date = 8;

    /*
    A bare-bones invoice for a payment within the Lightning Network. With the
    details of the invoice, the sender has all the data necessary to send a
    payment to the recipient.
    */
    string payment_request = 9;

    /*
    Hash (SHA-256) of a description of the payment. Used if the description of
    payment (memo) is too long to naturally fit within the description field
    of an encoded payment request. When using REST, this field must be encoded
    as base64.
    */
    bytes description_hash = 10;

    // Payment request expiry time in seconds. Default is 3600 (1 hour).
    int64 expiry = 11;

    // Fallback on-chain address.
    string fallback_addr = 12;

    // Delta to use for the time-lock of the CLTV extended to the final hop.
    uint64 cltv_expiry = 13;

    /*
    Route hints that can each be individually used to assist in reaching the
    invoice's destination.
    */
    repeated RouteHint route_hints = 14;

    // Whether this invoice should include routing hints for private channels.
    bool private = 15;

    /*
    The "add" index of this invoice. Each newly created invoice will increment
    this index making it monotonically increasing. Callers to the
    SubscribeInvoices call can use this to instantly get notified of all added
    invoices with an add_index greater than this one.
    */
    uint64 add_index = 16;

    /*
    The "settle" index of this invoice. Each newly settled invoice will
    increment this index making it monotonically increasing. Callers to the
    SubscribeInvoices call can use this to instantly get notified of all
    settled invoices with an settle_index greater than this one.
    */
    uint64 settle_index = 17;

    // Deprecated, use amt_paid_sat or amt_paid_msat.
    int64 amt_paid = 18 [deprecated = true];

    /*
    The amount that was accepted for this invoice, in satoshis. This will ONLY
    be set if this invoice has been settled. We provide this field as if the
    invoice was created with a zero value, then we need to record what amount
    was ultimately accepted. Additionally, it's possible that the sender paid
    MORE that was specified in the original invoice. So we'll record that here
    as well.
    */
    int64 amt_paid_sat = 19;

    /*
    The amount that was accepted for this invoice, in millisatoshis. This will
    ONLY be set if this invoice has been settled. We provide this field as if
    the invoice was created with a zero value, then we need to record what
    amount was ultimately accepted. Additionally, it's possible that the sender
    paid MORE that was specified in the original invoice. So we'll record that
    here as well.
    */
    int64 amt_paid_msat = 20;

    enum InvoiceState {
        OPEN = 0;
        SETTLED = 1;
        CANCELED = 2;
        ACCEPTED = 3;
    }

    /*
    The state the invoice is in.
    */
    InvoiceState state = 21;

    // List of HTLCs paying to this invoice [EXPERIMENTAL].
    repeated InvoiceHTLC htlcs = 22;

    // List of features advertised on the invoice.
    map<uint32, Feature> features = 24;

    /*
    Indicates if this invoice was a spontaneous payment that arrived via keysend
    [EXPERIMENTAL].
    */
    bool is_keysend = 25;

    /*
    The payment address of this invoice. This value will be used in MPP
    payments, and also for newer invoies that always require the MPP paylaod
    for added end-to-end security.
    */
    bytes payment_addr = 26;
}

enum InvoiceHTLCState {
    ACCEPTED = 0;
    SETTLED = 1;
    CANCELED = 2;
}

// Details of an HTLC that paid to an invoice
message InvoiceHTLC {
    // Short channel id over which the htlc was received.
    uint64 chan_id = 1 [jstype = JS_STRING];

    // Index identifying the htlc on the channel.
    uint64 htlc_index = 2;

    // The amount of the htlc in msat.
    uint64 amt_msat = 3;

    // Block height at which this htlc was accepted.
    int32 accept_height = 4;

    // Time at which this htlc was accepted.
    int64 accept_time = 5;

    // Time at which this htlc was settled or canceled.
    int64 resolve_time = 6;

    // Block height at which this htlc expires.
    int32 expiry_height = 7;

    // Current state the htlc is in.
    InvoiceHTLCState state = 8;

    // Custom tlv records.
    map<uint64, bytes> custom_records = 9;

    // The total amount of the mpp payment in msat.
    uint64 mpp_total_amt_msat = 10;
}

message AddInvoiceResponse {
    bytes r_hash = 1;

    /*
    A bare-bones invoice for a payment within the Lightning Network. With the
    details of the invoice, the sender has all the data necessary to send a
    payment to the recipient.
    */
    string payment_request = 2;

    /*
    The "add" index of this invoice. Each newly created invoice will increment
    this index making it monotonically increasing. Callers to the
    SubscribeInvoices call can use this to instantly get notified of all added
    invoices with an add_index greater than this one.
    */
    uint64 add_index = 16;

    /*
    The payment address of the generated invoice. This value should be used
    in all payments for this invoice as we require it for end to end
    security.
    */
    bytes payment_addr = 17;
}
message PaymentHash {
    /*
    The hex-encoded payment hash of the invoice to be looked up. The passed
    payment hash must be exactly 32 bytes, otherwise an error is returned.
    Deprecated now that the REST gateway supports base64 encoding of bytes
    fields.
    */
    string r_hash_str = 1 [deprecated = true];

    /*
    The payment hash of the invoice to be looked up. When using REST, this field
    must be encoded as base64.
    */
    bytes r_hash = 2;
}

message InvoiceSubscription {
    /*
    If specified (non-zero), then we'll first start by sending out
    notifications for all added indexes with an add_index greater than this
    value. This allows callers to catch up on any events they missed while they
    weren't connected to the streaming RPC.
    */
    uint64 add_index = 1;

    /*
    If specified (non-zero), then we'll first start by sending out
    notifications for all settled indexes with an settle_index greater than
    this value. This allows callers to catch up on any events they missed while
    they weren't connected to the streaming RPC.
    */
    uint64 settle_index = 2;
}

enum PaymentFailureReason {
    /*
    Payment isn't failed (yet).
    */
    FAILURE_REASON_NONE = 0;

    /*
    There are more routes to try, but the payment timeout was exceeded.
    */
    FAILURE_REASON_TIMEOUT = 1;

    /*
    All possible routes were tried and failed permanently. Or were no
    routes to the destination at all.
    */
    FAILURE_REASON_NO_ROUTE = 2;

    /*
    A non-recoverable error has occured.
    */
    FAILURE_REASON_ERROR = 3;

    /*
    Payment details incorrect (unknown hash, invalid amt or
    invalid final cltv delta)
    */
    FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4;

    /*
    Insufficient local balance.
    */
    FAILURE_REASON_INSUFFICIENT_BALANCE = 5;
}

message Payment {
    // The payment hash
    string payment_hash = 1;

    // Deprecated, use value_sat or value_msat.
    int64 value = 2 [deprecated = true];

    // Deprecated, use creation_time_ns
    int64 creation_date = 3 [deprecated = true];

    reserved 4;

    // Deprecated, use fee_sat or fee_msat.
    int64 fee = 5 [deprecated = true];

    // The payment preimage
    string payment_preimage = 6;

    // The value of the payment in satoshis
    int64 value_sat = 7;

    // The value of the payment in milli-satoshis
    int64 value_msat = 8;

    // The optional payment request being fulfilled.
    string payment_request = 9;

    enum PaymentStatus {
        UNKNOWN = 0;
        IN_FLIGHT = 1;
        SUCCEEDED = 2;
        FAILED = 3;
    }

    // The status of the payment.
    PaymentStatus status = 10;

    //  The fee paid for this payment in satoshis
    int64 fee_sat = 11;

    //  The fee paid for this payment in milli-satoshis
    int64 fee_msat = 12;

    // The time in UNIX nanoseconds at which the payment was created.
    int64 creation_time_ns = 13;

    // The HTLCs made in attempt to settle the payment.
    repeated HTLCAttempt htlcs = 14;

    /*
    The creation index of this payment. Each payment can be uniquely identified
    by this index, which may not strictly increment by 1 for payments made in
    older versions of lnd.
    */
    uint64 payment_index = 15;

    PaymentFailureReason failure_reason = 16;
}

message HTLCAttempt {
    enum HTLCStatus {
        IN_FLIGHT = 0;
        SUCCEEDED = 1;
        FAILED = 2;
    }

    // The status of the HTLC.
    HTLCStatus status = 1;

    // The route taken by this HTLC.
    Route route = 2;

    // The time in UNIX nanoseconds at which this HTLC was sent.
    int64 attempt_time_ns = 3;

    /*
    The time in UNIX nanoseconds at which this HTLC was settled or failed.
    This value will not be set if the HTLC is still IN_FLIGHT.
    */
    int64 resolve_time_ns = 4;

    // Detailed htlc failure info.
    Failure failure = 5;

    // The preimage that was used to settle the HTLC.
    bytes preimage = 6;
}

message PayReqString {
    // The payment request string to be decoded
    string pay_req = 1;
}
message PayReq {
    string destination = 1;
    string payment_hash = 2;
    int64 num_satoshis = 3;
    int64 timestamp = 4;
    int64 expiry = 5;
    string description = 6;
    string description_hash = 7;
    string fallback_addr = 8;
    int64 cltv_expiry = 9;
    repeated RouteHint route_hints = 10;
    bytes payment_addr = 11;
    int64 num_msat = 12;
    map<uint32, Feature> features = 13;
}

enum FeatureBit {
    DATALOSS_PROTECT_REQ = 0;
    DATALOSS_PROTECT_OPT = 1;
    INITIAL_ROUING_SYNC = 3;
    UPFRONT_SHUTDOWN_SCRIPT_REQ = 4;
    UPFRONT_SHUTDOWN_SCRIPT_OPT = 5;
    GOSSIP_QUERIES_REQ = 6;
    GOSSIP_QUERIES_OPT = 7;
    TLV_ONION_REQ = 8;
    TLV_ONION_OPT = 9;
    EXT_GOSSIP_QUERIES_REQ = 10;
    EXT_GOSSIP_QUERIES_OPT = 11;
    STATIC_REMOTE_KEY_REQ = 12;
    STATIC_REMOTE_KEY_OPT = 13;
    PAYMENT_ADDR_REQ = 14;
    PAYMENT_ADDR_OPT = 15;
    MPP_REQ = 16;
    MPP_OPT = 17;
}

message Feature {
    string name = 2;
    bool is_required = 3;
    bool is_known = 4;
}

message Failure {
    enum FailureCode {
        /*
        The numbers assigned in this enumeration match the failure codes as
        defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
        a RESERVED value is added.
        */
        RESERVED = 0;

        INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1;
        INCORRECT_PAYMENT_AMOUNT = 2;
        FINAL_INCORRECT_CLTV_EXPIRY = 3;
        FINAL_INCORRECT_HTLC_AMOUNT = 4;
        FINAL_EXPIRY_TOO_SOON = 5;
        INVALID_REALM = 6;
        EXPIRY_TOO_SOON = 7;
        INVALID_ONION_VERSION = 8;
        INVALID_ONION_HMAC = 9;
        INVALID_ONION_KEY = 10;
        AMOUNT_BELOW_MINIMUM = 11;
        FEE_INSUFFICIENT = 12;
        INCORRECT_CLTV_EXPIRY = 13;
        CHANNEL_DISABLED = 14;
        TEMPORARY_CHANNEL_FAILURE = 15;
        REQUIRED_NODE_FEATURE_MISSING = 16;
        REQUIRED_CHANNEL_FEATURE_MISSING = 17;
        UNKNOWN_NEXT_PEER = 18;
        TEMPORARY_NODE_FAILURE = 19;
        PERMANENT_NODE_FAILURE = 20;
        PERMANENT_CHANNEL_FAILURE = 21;
        EXPIRY_TOO_FAR = 22;
        MPP_TIMEOUT = 23;

        /*
        An internal error occurred.
        */
        INTERNAL_FAILURE = 997;

        /*
        The error source is known, but the failure itself couldn't be decoded.
        */
        UNKNOWN_FAILURE = 998;

        /*
        An unreadable failure result is returned if the received failure message
        cannot be decrypted. In that case the error source is unknown.
        */
        UNREADABLE_FAILURE = 999;
    }

    // Failure code as defined in the Lightning spec
    FailureCode code = 1;

    reserved 2;

    // An optional channel update message.
    ChannelUpdate channel_update = 3;

    // A failure type-dependent htlc value.
    uint64 htlc_msat = 4;

    // The sha256 sum of the onion payload.
    bytes onion_sha_256 = 5;

    // A failure type-dependent cltv expiry value.
    uint32 cltv_expiry = 6;

    // A failure type-dependent flags value.
    uint32 flags = 7;

    /*
    The position in the path of the intermediate or final node that generated
    the failure message. Position zero is the sender node.
    **/
    uint32 failure_source_index = 8;

    // A failure type-dependent block height.
    uint32 height = 9;
}

message ChannelUpdate {
    /*
    The signature that validates the announced data and proves the ownership
    of node id.
    */
    bytes signature = 1;

    /*
    The target chain that this channel was opened within. This value
    should be the genesis hash of the target chain. Along with the short
    channel ID, this uniquely identifies the channel globally in a
    blockchain.
    */
    bytes chain_hash = 2;

    /*
    The unique description of the funding transaction.
    */
    uint64 chan_id = 3 [jstype = JS_STRING];

    /*
    A timestamp that allows ordering in the case of multiple announcements.
    We should ignore the message if timestamp is not greater than the
    last-received.
    */
    uint32 timestamp = 4;

    /*
    The bitfield that describes whether optional fields are present in this
    update. Currently, the least-significant bit must be set to 1 if the
    optional field MaxHtlc is present.
    */
    uint32 message_flags = 10;

    /*
    The bitfield that describes additional meta-data concerning how the
    update is to be interpreted. Currently, the least-significant bit must be
    set to 0 if the creating node corresponds to the first node in the
    previously sent channel announcement and 1 otherwise. If the second bit
    is set, then the channel is set to be disabled.
    */
    uint32 channel_flags = 5;

    /*
    The minimum number of blocks this node requires to be added to the expiry
    of HTLCs. This is a security parameter determined by the node operator.
    This value represents the required gap between the time locks of the
    incoming and outgoing HTLC's set to this node.
    */
    uint32 time_lock_delta = 6;

    /*
    The minimum HTLC value which will be accepted.
    */
    uint64 htlc_minimum_msat = 7;

    /*
    The base fee that must be used for incoming HTLC's to this particular
    channel. This value will be tacked onto the required for a payment
    independent of the size of the payment.
    */
    uint32 base_fee = 8;

    /*
    The fee rate that will be charged per millionth of a satoshi.
    */
    uint32 fee_rate = 9;

    /*
    The maximum HTLC value which will be accepted.
    */
    uint64 htlc_maximum_msat = 11;

    /*
    The set of data that was appended to this message, some of which we may
    not actually know how to iterate or parse. By holding onto this data, we
    ensure that we're able to properly validate the set of signatures that
    cover these new fields, and ensure we're able to make upgrades to the
    network in a forwards compatible manner.
    */
    bytes extra_opaque_data = 12;
}

